<?xml version="1.0" encoding="UTF-8"?>
<root>
  <mk>
    <dir>/util</dir>
    <dir>/service</dir>
    <dir>/service/interfaces</dir>
    <dir>/security</dir>
    <dir>/response</dir>
    <dir>/property</dir>
    <dir>/exception</dir>
    <dir>/entity</dir>
    <dir>/dao</dir>
    <dir>/controller</dir>
  </mk>

  <success>Structure was created</success>

  <!--Util forlder-->
  <layout extension=".java" dir="/util/Text">${package}

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Method;

import java.util.Base64;
import java.util.UUID;


public class Text {

	private static final Logger logger = LoggerFactory.getLogger(Text.class);

	private Text() {
		throw new IllegalStateException("Problems in: " + Text.class);
	}

	public static String toJSONString(Object obj) {
		try {
			StringBuilder bld = new StringBuilder();
			Method[] methods = obj.getClass().getMethods();
			bld.append("{\n");

			for (int i = 0; i ${(} methods.length; i++) {
				if (
					methods[i].getName().contains("get") ${and}${and}
					(!methods[i].getName().equals("getClass"))
				) {
					bld.append(
						"  \"" + formatKey(methods[i].getName()) + "\": " +
						"\"" + methods[i].invoke(obj) + "\",\n"
					);
				}
			}

			return bld.substring(0, bld.length() - 2) + "\n}";
		} catch (Exception e) {
			logger.error(
				"Problem when converting the class to json string, "
				 + "it is necessary to generate the getter and setter "
				 + "methods in your entity"
			);
		}

		return "";
	}

	public static String uniqueString() {
		String originalInput = UUID.randomUUID().toString().substring(0, 12);
		return Base64.getEncoder().encodeToString(originalInput.getBytes());
	}

	private static Object formatKey(Object stg) {
		String out = stg.toString()
			.replace("get","");
		String  initialLyrics = String.valueOf(out.charAt(0))
			.toLowerCase();
		return initialLyrics + out.substring(1);
	}
}
  </layout>

  <layout extension=".java" dir="/util/Response">${package}

import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;

@Component
public class Response {

	public ResponseEntity${(}Object> ok(String message, Object data) {
		return response(message, data, HttpStatus.OK);
	}

	public ResponseEntity${(}Object> ok(String message) {
		return response(message, null, HttpStatus.OK);
	}

	public ResponseEntity${(}Object> ok(Object data) {
		return response(null, data, HttpStatus.OK);
	}


	public ResponseEntity${(}Object> created(String message, Object data) {
		return response(message, data, HttpStatus.CREATED);
	}

	public ResponseEntity${(}Object> created(String message) {
		return response(message, null, HttpStatus.CREATED);
	}

	public ResponseEntity${(}Object> created(Object data) {
		return response(null, data, HttpStatus.CREATED);
	}


	private ResponseEntity${(}Object> response(String message, Object data, HttpStatus status) {
		Map${(}String, Object> resp = new LinkedHashMap${(}>();
		resp.put("timestamp", new Date());
		resp.put("status", status.value());

		if (message != null) {
			resp.put("message", message);
		}

		if (data != null) {
			resp.put("data", data);
		}

		return new ResponseEntity${(}> (
			resp,
			status
		);
	}

}
  </layout>

  <layout extension=".java" dir="/util/Resource">${package}

import java.io.IOException;
import java.io.InputStream;

import java.nio.charset.StandardCharsets;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;
import org.springframework.util.FileCopyUtils;

@Component
public class Resource {

	private static final Logger logger = LoggerFactory.getLogger(Resource.class);

	public String load(String res) {
		try {
			ClassPathResource resource = new ClassPathResource(res);
			InputStream inputStream = resource.getInputStream();
			byte[] bdata = FileCopyUtils.copyToByteArray(inputStream);
			return new String(bdata, StandardCharsets.UTF_8);
		} catch (IOException e) {
			logger.error(e.getMessage());
		}
		return "";
	}


	public String passwordTemplate(String user, String firstPart, String secondPart, String password, String createdBy, String description) {
		try {
			ClassPathResource resource = new ClassPathResource("password-template.html");
			InputStream inputStream = resource.getInputStream();
			byte[] bdata = FileCopyUtils.copyToByteArray(inputStream);
			String data = new String(bdata, StandardCharsets.UTF_8);

			data = data.replace("${user}", user)
				.replace("${firstPart}", firstPart)
				.replace("${secondPart}", secondPart)
				.replace("${password}", password)
				.replace("${createdBy}", createdBy)
				.replace("${description}", description);

			return data;
		} catch (IOException e) {
			logger.error(e.getMessage());
		}

		return "";
	}
}
  </layout>

  <layout extension=".java" dir="/util/Request">${package}

import java.util.List;
import java.util.Map;

import ${intoSrc}.exception.BadRequestException;

import org.springframework.stereotype.Component;

@Component
public class Request {

	private String badMessage;

	public Request() {
		this.badMessage = " field not found";
	}

		public Long getLong(Object req, String key) {
		Object reqOut = ((Map${(}?, ?>) req).get(key);

		if (reqOut != null) {
			return Long.valueOf(reqOut.toString());
		}

		throw new BadRequestException(key + badMessage);
	}


	public String getString(Object req, String key) {
		Object reqOut = ((Map${(}?, ?>) req).get(key);

		if (reqOut != null) {
			return reqOut.toString();
		}

		throw new BadRequestException(key + badMessage);
	}


	public boolean getBoolean(Object req, String key) {
		Object reqOut = ((Map${(}?, ?>) req).get(key);

		if (reqOut != null) {
				return reqOut.toString().equals("true");
		}

		throw new BadRequestException(key + badMessage);
	}


	public List${(}Object> getList(Object req, String key) {
		Object reqOut = ((Map${(}?, ?>) req).get(key);

		if (reqOut != null) {
			return (List${(}Object>) reqOut;
		}

		throw new BadRequestException(key  + badMessage);
	}

}
  </layout>

  <layout extension=".java" dir="/util/Mail">${package}

import java.util.Date;
import java.util.Properties;

import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class Mail {

	@Value("${app.auth.mail-user}")
	private String user;

	@Value("${app.auth.mail-password}")
	private String password;

	public boolean send(String subject, String content, String... emails) {
		boolean out = true;

		for (String email : emails) {
			out = out ${and}${and} sendIndividual(email, subject, content);
		}

		return out;
	}

	private boolean sendIndividual(String email, String subject, String content) {
		try {
			Properties props = new Properties();
			props.put("mail.smtp.auth", "true");
			props.put("mail.smtp.starttls.enable", "true");
			props.put("mail.smtp.host", "smtp.gmail.com");
			props.put("mail.smtp.port", "587");

			Session session = Session.getInstance(props,
				new javax.mail.Authenticator() {
					protected PasswordAuthentication getPasswordAuthentication() {
						return new PasswordAuthentication(
							user,
							password
						);
					}
				}
			);

			Message msg = new MimeMessage(session);
			msg.setFrom(new InternetAddress("javabrain.email@gmail.com", false));
			msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(email));
			msg.setSubject(subject);
			msg.setContent(content, "text/html");
			msg.setSentDate(new Date());

			Transport.send(msg);
		} catch (MessagingException e) {
			e.printStackTrace();
			return false;
		}

		return true;
	}

}
  </layout>
  <!--=================================================-->

  <!--Service-->
  <layout extension=".java" dir="/service/UserServiceImp">${package}

import java.util.Map;

import ${intoSrc}.dao.IUserDAO;
import ${intoSrc}.entity.User;
import ${intoSrc}.exception.BadRequestException;
import ${intoSrc}.response.UserResp;
import ${intoSrc}.service.interfaces.IUserService;
import ${intoSrc}.util.Request;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserServiceImp implements IUserService {

	@Autowired
	Request request;

	@Autowired
	UserResp response;

	@Autowired
	private PasswordEncoder encoder;

	@Autowired
	private IUserDAO userDao;

	@Value("${app.auth.user-no-exist}")
	private String userNoExist;

	@Value("${app.auth.user-activated}")
	private String userActivated;

	@Value("${app.auth.user-update}")
	private String userUpdated;

	@Value("${app.auth.user-exist}")
	private String userExist;

	@Value("${app.auth.phone-number-exist}")
	private String phoneNumberExist;

	@Value("${app.auth.user-blocked}")
	private String userBlockedM;

	@Value("${app.auth.user-unlocked}")
	private String userUnlocked;

	@Value("${app.auth.user-deleted}")
	private String userDeleted;

	@Value("${app.auth.user-was-signin}")
	private String userWasSignin;


	@Override
	@Transactional
	public ResponseEntity${(}Object> firstSignin(Long id, Map${(}String, Object> req) {

		User user = userDao.findById(id).orElseThrow(() ->
			new BadRequestException(userNoExist)
		);

		if (user.isFirstSession()) {
			user.setFirstSession(false);
			user.setPassword(
				encoder.encode(
					request.getString(req, "password")
				)
			);
		} else {
			throw new BadRequestException(userWasSignin);
		}

		userDao.save(user);
		return response.firstSignin(userActivated);
	}


	@Override
	@Transactional
	public ResponseEntity${(}Object> update(Long id, Map${(}String, Object> req) {

		User userUpdate = userDao.findById(id).orElseThrow(() ->
			new BadRequestException(userNoExist)
		);

		userOrPhoneNumberExist(id, req);

		userUpdate.setUserName(request.getString(req, "userName"));
		userUpdate.setPhoneNumber(request.getString(req, "phoneNumber"));
		userUpdate.setLastName(request.getString(req, "lastName"));
		userUpdate.setImageUrl(request.getString(req, "imageUrl"));
		userUpdate.setName(request.getString(req, "name"));
		userDao.save(userUpdate);

		return response.updateUserResp(userUpdated, userUpdate);
	}


	@Override
	@Transactional
	public ResponseEntity${(}Object> blocked(Long id, Map${(}String, Object> req) {

		boolean blocked = request.getBoolean(req, "blocked");
		User userBlocked = userDao.findById(id).orElseThrow(() ->
			new BadRequestException(userNoExist)
		);
		userBlocked.setBlocked(blocked);
		userDao.save(userBlocked);

		if (blocked) {
			return response.blocked(userBlockedM);
		}

		return response.blocked(userUnlocked);
	}

	@Override
	@Transactional
	public ResponseEntity${(}Object> delete(Long id) {
		User userDelete = userDao.findById(id).orElseThrow(() ->
			new BadRequestException(userNoExist)
		);
		userDelete.setDelete(true);
		userDao.save(userDelete);

		return response.delete(userDeleted);
	}


	private void userOrPhoneNumberExist(Long id, Map${(}String, Object> req) {
		User user = userDao.findByUserName(
			request.getString(req, "userName")
		).orElse(null);
		if (notExistUser(id, user)) {
			throw new BadRequestException(userExist);
		}

		User userPhoneNumber = userDao.findByPhoneNumber(
			request.getString(req, "phoneNumber")
		).orElse(null);
		if (notExistUser(id, userPhoneNumber)) {
			throw new BadRequestException(phoneNumberExist);
		}
	}

	private boolean notExistUser(Long id, User user) {
		if (user == null) {
			return false;
		}

		return !id.equals(user.getId());
	}

}
  </layout>

  <layout extension=".java" dir="/service/AuthServiceImpl">${package}

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ${intoSrc}.dao.IRoleDAO;
import ${intoSrc}.dao.IUserDAO;
import ${intoSrc}.entity.Role;
import ${intoSrc}.entity.User;
import ${intoSrc}.exception.BadRequestException;
import ${intoSrc}.exception.UnauthorizedException;
import ${intoSrc}.response.AuthResp;
import ${intoSrc}.security.JwtProvider;
import ${intoSrc}.security.UserPrinciple;
import ${intoSrc}.service.interfaces.IAuthService;
import ${intoSrc}.util.Mail;
import ${intoSrc}.util.Request;
import ${intoSrc}.util.Resource;
import ${intoSrc}.util.Text;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class AuthServiceImpl implements IAuthService, UserDetailsService {

	@Autowired
	private AuthenticationManager authenticationManager;

	@Autowired
	private JwtProvider jwtProvider;

	@Autowired
	private PasswordEncoder encoder;

	@Autowired
	private Mail mail;

	@Autowired
	private Resource resource;

	@Autowired
	private AuthResp response;

	@Autowired
	private Request request;

	@Autowired
	private IUserDAO userDao;

	@Autowired
	private IRoleDAO roleDao;

	@Value("${app.auth.user-no-exist}")
	private String userNoExist;

	@Value("${app.auth.user-no-password}")
	private String userNoPassowrd;

	@Value("${app.auth.user-exist}")
	private String userExist;

	@Value("${app.auth.user-created}")
	private String userCreated;

	@Value("${app.auth.user-change-password}")
	private String userChangePassword;

	@Value("${app.auth.user-recover-password}")
	private String userRecoverPassword;

	@Value("${app.auth.mail-exist}")
	private String mailExist;

	@Value("${app.auth.phone-number-exist}")
	private String phoneNumberExist;

	@Value("${app.auth.mail-subject}")
	private String mailSubject;

	@Value("${app.auth.mail-message}")
	private String mailMessage;

	@Value("${app.auth.mail-sub-message}")
	private String mailSubMessage;

	@Value("${app.auth.mail-app-name}")
	private String mailAppName;

	@Value("${app.auth.mail-app-description}")
	private String mailAppDescription;

	@Value("${app.auth.mail-recover-message}")
	private String mailRecoverMessage;

	@Value("${app.auth.mail-recover-sub-message}")
	private String mailRecoverSubMessage;

	private String userNameRef;
	private String emailRef;

	public AuthServiceImpl() {
		this.userNameRef = "userName";
		this.emailRef = "email";
	}

	@Override
	@Transactional
	public UserDetails loadUserByUsername(String userName) {

		User user = userDao.findByUserName(userName).orElseThrow(() ->
			new UsernameNotFoundException(userNoExist)
		);

		return UserPrinciple.build(user);
	}


	@Override
	@Transactional
	public ResponseEntity${(}Object> signup(Map${(}String, Object> req) {

		existUser(req);

		String password = Text.uniqueString();
		User user = new User();
		user.setName(request.getString(req, "name"));
		user.setLastName(request.getString(req, "lastName"));
		user.setPhoneNumber(request.getString(req, "phoneNumber"));
		user.setImageUrl(request.getString(req, "imageUrl"));
		user.setUserName(request.getString(req, this.userNameRef));
		user.setEmail(request.getString(req, this.emailRef));
		user.setPassword(encoder.encode(password));
		user.setFirstSession(true);

		List${(}Role> roles = new ArrayList${(}>();
		roles.add(roleDao.findById(1l).orElse(null));
		user.setRoles(roles);
		User userOut = userDao.save(user);

		mail.send(
			mailSubject,
			resource.passwordTemplate(
				userOut.getName(),
				mailMessage,
				mailSubMessage,
				password,
				mailAppName,
				mailAppDescription
			),
			userOut.getEmail()
		);

		return response.signupResp(userOut, userCreated);
	}


	@Override
	@Transactional
	public ResponseEntity${(}Object> signin(Map${(}String, Object> req) {

		String userName = request.getString(req, this.userNameRef);
		User user = searchUserName(userName);
		String jwt;

		try {
			Authentication authentication = authenticationManager.authenticate(
				new UsernamePasswordAuthenticationToken(
					user.getUserName(),
					request.getString(req, "password")
				)
			);

			SecurityContextHolder.getContext().setAuthentication(authentication);
			jwt = jwtProvider.generateJwtToken(authentication);
			user.setRecoverCode("");
			userDao.save(user);
		} catch (Exception e) {
			throw new UnauthorizedException(userNoPassowrd);
		}

		return response.signinResp(jwt, user);
	}


	@Override
	@Transactional
	public ResponseEntity${(}Object> recoverPassword(Map${(}String, Object> req) {

		User userEmail = userDao.findByEmail(request.getString(req, "email"))
			.orElseThrow(() -> new BadRequestException(userNoExist));

		String password = Text.uniqueString();

		mail.send(
			mailSubject,
			resource.passwordTemplate(
				userEmail.getName(),
				mailRecoverMessage,
				mailRecoverSubMessage,
				password,
				mailAppName,
				mailAppDescription
			),
			userEmail.getEmail()
		);

		userEmail.setRecoverCode(password);
		userDao.save(userEmail);
		return response.recoverPassword(userRecoverPassword);
	}


	@Override
	@Transactional
	public ResponseEntity${(}Object> changePassword(Map${(}String, Object> req) {

		User userChange = userDao.findByRecoverCode(request.getString(req, "code"))
			.orElseThrow(() -> new BadRequestException(userNoExist));
		userChange.setPassword(
			encoder.encode(
				request.getString(req, "password")
			)
		);
		userChange.setRecoverCode("");

		userDao.save(userChange);
		return response.changePassword(userChangePassword);
	}


	private void existUser(Map${(}String, Object> req) {

		User userName = userDao.findByUserName(
			request.getString(req, this.userNameRef)
		).orElse(null);
		if (userName != null) {
			throw new BadRequestException(userExist);
		}

		User userEmail = userDao.findByEmail(
			request.getString(req, this.emailRef)
		).orElse(null);
		if (userEmail != null) {
			throw new BadRequestException(mailExist);
		}

		User userPhone = userDao.findByPhoneNumber(
			request.getString(req, "phoneNumber")
		).orElse(null);
		if (userPhone != null) {
			throw new BadRequestException(phoneNumberExist);
		}
	}


	private User searchUserName(String userName) {
		User user = userDao.findByUserName(userName).orElse(null);

		if (user == null) {
			user = userDao.findByEmail(userName).orElse(null);
			if (user == null) {
				user = userDao.findByPhoneNumber(userName).orElseThrow(() ->
					new UnauthorizedException(userNoExist)
				);
			}
		}

		return user;
	}

}
  </layout>
  <!--=================================================-->

  <!--service/interfaces-->
  <layout extension=".java" dir="/service/interfaces/IUserService">${package}

import java.util.Map;

import org.springframework.http.ResponseEntity;

public interface IUserService {
	ResponseEntity${(}Object> firstSignin(Long id, Map${(}String, Object> req);
	ResponseEntity${(}Object> update(Long id, Map${(}String, Object> req);
	ResponseEntity${(}Object> blocked(Long id, Map${(}String, Object> req);
	ResponseEntity${(}Object> delete(Long id);
}
  </layout>

  <layout extension=".java" dir="/service/interfaces/IAuthService">${package}

import java.util.Map;

import org.springframework.http.ResponseEntity;

public interface IAuthService {
	ResponseEntity${(}Object> signup(Map${(}String, Object> req);
	ResponseEntity${(}Object> signin(Map${(}String, Object> req);
	ResponseEntity${(}Object> recoverPassword(Map${(}String, Object> req);
	ResponseEntity${(}Object> changePassword(Map${(}String, Object> req);
}
  </layout>
  <!--=================================================-->

  <!--security-->
  <layout extension=".java" dir="/security/WebSecurityConfig">${package}

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import ${intoSrc}.service.AuthServiceImpl;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(
	prePostEnabled = true
)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	AuthServiceImpl userDetailsService;

	@Autowired
	private JwtAuthEntryPoint unauthorizedHandler;

	@Bean
	public JwtAuthTokenFilter authenticationJwtTokenFilter() {
		return new JwtAuthTokenFilter();
	}

	@Override
	public void configure(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception {
		authenticationManagerBuilder
			.userDetailsService(userDetailsService)
			.passwordEncoder(passwordEncoder());
	}

	@Bean
	@Override
	public AuthenticationManager authenticationManagerBean() throws Exception {
		return super.authenticationManagerBean();
	}

	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.cors().and().csrf().disable().
			authorizeRequests()
				.antMatchers("/auth/**").permitAll()
				.anyRequest().authenticated()
				.and()
				.exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()
				.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);

		http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);
	}

}
  </layout>

  <layout extension=".java" dir="/security/UserPrinciple">${package}

import com.fasterxml.jackson.annotation.JsonIgnore;

import ${intoSrc}.entity.User;
import ${intoSrc}.util.Text;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

public class UserPrinciple implements UserDetails {

	private static final long serialVersionUID = 1L;

	private Long id;

	private String name;

	private String username;

	private String email;

	@JsonIgnore
	private String password;

	private Collection${(}? extends GrantedAuthority> authorities;

	public UserPrinciple(
		Long id, String name,
		String username, String email, String password,
		Collection${(}? extends GrantedAuthority> authorities
	) {
		this.id = id;
		this.name = name;
		this.username = username;
		this.email = email;
		this.password = password;
		this.authorities = authorities;
	}

	public static UserPrinciple build(User user) {
		List${(}GrantedAuthority> authorities =
			user.getRoles().stream().map(role ->
				new SimpleGrantedAuthority(role.getName())
			).collect(Collectors.toList());

		return new UserPrinciple(
			user.getId(),
			user.getName(),
			user.getUserName(),
			user.getEmail(),
			user.getPassword(),
			authorities
		);
	}

	public Long getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public String getEmail() {
		return email;
	}

	@Override
	public String getUsername() {
		return username;
	}

	@Override
	public String getPassword() {
		return password;
	}

	@Override
	public Collection${(}? extends GrantedAuthority> getAuthorities() {
		return authorities;
	}

	@Override
	public boolean isAccountNonExpired() {
		return true;
	}

	@Override
	public boolean isAccountNonLocked() {
		return true;
	}

	@Override
	public boolean isCredentialsNonExpired() {
		return true;
	}

	@Override
	public boolean isEnabled() {
		return true;
	}

	@Override
	public String toString() {
		return Text.toJSONString(this);
	}

}
  </layout>

  <layout extension=".java" dir="/security/JwtProvider">${package}

import io.jsonwebtoken.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class JwtProvider {

	private static final Logger logger = LoggerFactory.getLogger(JwtProvider.class);

	@Value("${app.auth.jwt-secret}")
	private String jwtSecret;

	@Value("${app.auth.jwt-expiration}")
	private int jwtExpiration;

	public String generateJwtToken(Authentication authentication) {
		UserPrinciple userPrincipal = (UserPrinciple) authentication.getPrincipal();

		return Jwts.builder()
			.setSubject((userPrincipal.getUsername()))
			.setIssuedAt(new Date())
			.setExpiration(new Date((new Date()).getTime() + jwtExpiration))
			.signWith(SignatureAlgorithm.HS512, jwtSecret)
			.compact();
	}

	public String getUserNameFromJwtToken(String token) {
		return Jwts.parser()
			.setSigningKey(jwtSecret)
			.parseClaimsJws(token)
			.getBody()
			.getSubject();
	}

	public boolean validateJwtToken(String authToken) {
		try {
			Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);
			return true;
		} catch (SignatureException e) {
			logger.error("Invalid JWT signature");
		} catch (MalformedJwtException e) {
			logger.error("Invalid JWT token");
		} catch (ExpiredJwtException e) {
			logger.error("Expired JWT token");
		} catch (UnsupportedJwtException e) {
			logger.error("Unsupported JWT token");
		} catch (IllegalArgumentException e) {
			logger.error("JWT claims string is empty");
		}

		return false;
	}

}
  </layout>

  <layout extension=".java" dir="/security/JwtAuthTokenFilter">${package}

import java.io.IOException;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.web.filter.OncePerRequestFilter;

import ${intoSrc}.service.AuthServiceImpl;

public class JwtAuthTokenFilter extends OncePerRequestFilter {

	@Autowired
	private JwtProvider tokenProvider;

	@Autowired
	private AuthServiceImpl userDetailsService;

	private static final Logger logger = LoggerFactory.getLogger(JwtAuthTokenFilter.class);

	@Override
	protected void doFilterInternal(
		HttpServletRequest request,
		HttpServletResponse response,
		FilterChain filterChain
	) throws ServletException, IOException {
		try {
			String jwt = getJwt(request);
			if (jwt!=null ${and}${and} tokenProvider.validateJwtToken(jwt)) {
				String username = tokenProvider.getUserNameFromJwtToken(jwt);

				UserDetails userDetails = userDetailsService.loadUserByUsername(username);
				UsernamePasswordAuthenticationToken authentication =
					new UsernamePasswordAuthenticationToken(
						userDetails,
						null,
						userDetails.getAuthorities()
					);

				authentication.setDetails(
					new WebAuthenticationDetailsSource()
						.buildDetails(request)
				);

				SecurityContextHolder.getContext().setAuthentication(authentication);
			}
		} catch (Exception e) {
			logger.error("Can NOT set user authentication");
		}

		filterChain.doFilter(request, response);
	}

	private String getJwt(HttpServletRequest request) {
		String authHeader = request.getHeader("Authorization");

		if (authHeader != null ${and}${and} authHeader.startsWith("Bearer ")) {
			return authHeader.replace("Bearer ","");
		}

		return null;
	}

}
  </layout>

  <layout extension=".java" dir="/security/JwtAuthEntryPoint">${package}

import java.io.IOException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

@Component
public class JwtAuthEntryPoint implements AuthenticationEntryPoint {

	@Override
	public void commence(
		HttpServletRequest request,
		HttpServletResponse response,
		AuthenticationException e
	) throws IOException {
		response.sendError(HttpServletResponse.SC_UNAUTHORIZED, e.getMessage());
	}

}
  </layout>
  <!--=================================================-->

  <!--response-->
  <layout extension=".java" dir="/response/AuthResp">${package}

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import ${intoSrc}.entity.Role;
import ${intoSrc}.entity.User;
import ${intoSrc}.util.Response;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;

@Component
public class AuthResp {

	@Autowired
	private Response response;


	public ResponseEntity${(}Object> signupResp(User user, String message) {

		Map${(}String, Object> resp = new LinkedHashMap${(}>();
		resp.put("id", user.getId());
		resp.put("name", user.getName());
		resp.put("lastName", user.getLastName());
		resp.put("phoneNumber", user.getPhoneNumber());
		resp.put("imageUrl", user.getImageUrl());
		resp.put("userName", user.getUserName());
		resp.put("email", user.getEmail());

		return response.created(message, resp);
	}


	public ResponseEntity${(}Object> signinResp(String token, User user) {

		Map${(}String, Object> resp = new LinkedHashMap${(}>();

		resp.put("id", user.getId());
		resp.put("type", "Bearer");
		resp.put("token", token);

		resp.put("name", user.getName());
		resp.put("lastName", user.getLastName());
		resp.put("phoneNumber", user.getPhoneNumber());
		resp.put("imageUrl", user.getImageUrl());
		resp.put("userName", user.getUserName());
		resp.put("email", user.getEmail());
		resp.put("firstSession", user.isFirstSession());
		List${(}String> roles = new ArrayList${(}>();

		for (Role role : user.getRoles()) {
			roles.add(role.getName());
		}

		resp.put("roles", roles);

		return response.ok(resp);
	}


	public ResponseEntity${(}Object> recoverPassword(String message) {
		return response.ok(message);
	}

	public ResponseEntity${(}Object> changePassword(String message) {
		return response.ok(message);
	}
}
  </layout>

  <layout extension=".java" dir="/response/UserResp">${package}

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import ${intoSrc}.entity.Role;
import ${intoSrc}.entity.User;
import ${intoSrc}.util.Response;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;

@Component
public class UserResp {

	@Autowired
	private Response response;


	public ResponseEntity${(}Object> firstSignin(String message) {
		return response.ok(message);
	}


	public ResponseEntity${(}Object> updateUserResp(String message, User user) {
		Map${(}String, Object> resp = new LinkedHashMap${(}>();

		resp.put("id", user.getId());
		resp.put("name", user.getName());
		resp.put("lastName", user.getLastName());
		resp.put("phoneNumber", user.getPhoneNumber());
		resp.put("imageUrl", user.getImageUrl());
		resp.put("userName", user.getUserName());
		resp.put("email", user.getEmail());
		List${(}String> roles = new ArrayList${(}>();

		for (Role role : user.getRoles()) {
			roles.add(role.getName());
		}

		resp.put("roles", roles);

		return response.ok(message, resp);
	}


	public ResponseEntity${(}Object> blocked(String message) {
		return response.ok(message);
	}


	public ResponseEntity${(}Object> delete(String message) {
		return response.ok(message);
	}

}
  </layout>
  <!--=================================================-->

  <!--property-->
  <layout extension=".java" dir="/property/AuthProperty">${package}

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties("app.auth")
public class AuthProperty {

	private String jwtSecret;
	private String jwtExpiration;

	private String mailUser;
	private String mailPassword;

	private String mailSubject;
	private String mailMessage;
	private String mailSubMessage;
	private String mailAppName;
	private String mailAppDescription;
	private String mailRecoverMessage;
	private String mailRecoverSubMessage;

	private String userNoExist;
	private String userNoPassword;
	private String userExist;
	private String mailExist;
	private String phoneNumberExist;
	private String userCreated;
	private String userActivated;
	private String userUpdate;
	private String userBlocked;
	private String userUnlocked;
	private String userDeleted;
	private String userRecoverPassword;
	private String userChangePassword;
	private String userWasSignin;


	public String getJwtSecret() {
		return jwtSecret;
	}

	public void setJwtSecret(String jwtSecret) {
		this.jwtSecret = jwtSecret;
	}

	public String getJwtExpiration() {
		return jwtExpiration;
	}

	public void setJwtExpiration(String jwtExpiration) {
		this.jwtExpiration = jwtExpiration;
	}

	public String getUserNoExist() {
		return userNoExist;
	}

	public void setUserNoExist(String userNoExist) {
		this.userNoExist = userNoExist;
	}

	public String getMailUser() {
		return mailUser;
	}

	public void setMailUser(String mailUser) {
		this.mailUser = mailUser;
	}

	public String getMailPassword() {
		return mailPassword;
	}

	public void setMailPassword(String mailPassword) {
		this.mailPassword = mailPassword;
	}

	public String getUserNoPassword() {
		return userNoPassword;
	}

	public void setUserNoPassword(String userNoPassword) {
		this.userNoPassword = userNoPassword;
	}

	public String getUserExist() {
		return userExist;
	}

	public void setUserExist(String userExist) {
		this.userExist = userExist;
	}

	public String getMailExist() {
		return mailExist;
	}

	public void setMailExist(String emailExist) {
		this.mailExist = emailExist;
	}

	public String getPhoneNumberExist() {
		return phoneNumberExist;
	}

	public void setPhoneNumberExist(String phoneNumberExist) {
		this.phoneNumberExist = phoneNumberExist;
	}

	public String getMailSubject() {
		return mailSubject;
	}

	public void setMailSubject(String mailSubject) {
		this.mailSubject = mailSubject;
	}

	public String getMailMessage() {
		return mailMessage;
	}

	public void setMailMessage(String mailMessage) {
		this.mailMessage = mailMessage;
	}

	public String getMailSubMessage() {
		return mailSubMessage;
	}

	public void setMailSubMessage(String mailSubMessage) {
		this.mailSubMessage = mailSubMessage;
	}

	public String getMailAppName() {
		return mailAppName;
	}

	public void setMailAppName(String mailAppName) {
		this.mailAppName = mailAppName;
	}

	public String getMailAppDescription() {
		return mailAppDescription;
	}

	public void setMailAppDescription(String mailAppDescription) {
		this.mailAppDescription = mailAppDescription;
	}

	public String getUserCreated() {
		return userCreated;
	}

	public void setUserCreated(String userCreated) {
		this.userCreated = userCreated;
	}

	public String getUserActivated() {
		return userActivated;
	}

	public void setUserActivated(String userActivated) {
		this.userActivated = userActivated;
	}

	public String getUserUpdate() {
		return userUpdate;
	}

	public void setUserUpdate(String userUpdate) {
		this.userUpdate = userUpdate;
	}

	public String getUserBlocked() {
		return userBlocked;
	}

	public void setUserBlocked(String userBlocked) {
		this.userBlocked = userBlocked;
	}

	public String getUserUnlocked() {
		return userUnlocked;
	}

	public void setUserUnlocked(String userUnlocked) {
		this.userUnlocked = userUnlocked;
	}

	public String getUserDeleted() {
		return userDeleted;
	}

	public void setUserDeleted(String userDeleted) {
		this.userDeleted = userDeleted;
	}

	public String getUserRecoverPassword() {
		return userRecoverPassword;
	}

	public void setUserRecoverPassword(String userRecoverPassword) {
		this.userRecoverPassword = userRecoverPassword;
	}

	public String getUserChangePassword() {
		return userChangePassword;
	}

	public void setUserChangePassword(String userChangePassword) {
		this.userChangePassword = userChangePassword;
	}

	public String getMailRecoverMessage() {
		return mailRecoverMessage;
	}

	public void setMailRecoverMessage(String mailRecoverMessage) {
		this.mailRecoverMessage = mailRecoverMessage;
	}

	public String getMailRecoverSubMessage() {
		return mailRecoverSubMessage;
	}

	public void setMailRecoverSubMessage(String mailRecoverSubMessage) {
		this.mailRecoverSubMessage = mailRecoverSubMessage;
	}

	public String getUserWasSignin() {
		return userWasSignin;
	}

	public void setUserWasSignin(String userWasSignin) {
		this.userWasSignin = userWasSignin;
	}

}
  </layout>
  <!--=================================================-->

  <!--exception-->
  <layout extension=".java" dir="/exception/UnauthorizedException">${package}

import org.springframework.http.HttpStatus;
import org.springframework.web.server.ResponseStatusException;

public class UnauthorizedException extends ResponseStatusException {

	private String developMessage;

	public UnauthorizedException(String reason) {
		super(HttpStatus.UNAUTHORIZED, reason);
	}

	public UnauthorizedException(String reason, String developMessage) {
		super(HttpStatus.FORBIDDEN, reason);
		this.developMessage = developMessage;
	}

	public String getDevelopMessage() {
		return developMessage;
	}

}
  </layout>

  <layout extension=".java" dir="/exception/InternalServerErrorException">${package}

import org.springframework.http.HttpStatus;
import org.springframework.web.server.ResponseStatusException;

public class InternalServerErrorException extends ResponseStatusException {

	private String developMessage;

	public InternalServerErrorException(String reason) {
		super(HttpStatus.INTERNAL_SERVER_ERROR, reason);
	}

	public InternalServerErrorException(String reason, String developMessage) {
		super(HttpStatus.FORBIDDEN, reason);
		this.developMessage = developMessage;
	}

	public String getDevelopMessage() {
		return developMessage;
	}

}
  </layout>

  <layout extension=".java" dir="/exception/HttpExceptionResponse">${package}

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ResponseStatusException;

import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;

@Component
public class HttpExceptionResponse {

	private static final Logger logger = LoggerFactory.getLogger(HttpExceptionResponse.class);

	public ResponseEntity${(}Object> error(ResponseStatusException e) {
		Map${(}String, Object> resp = new LinkedHashMap${(}>();
		resp.put("timestamp", new Date());
		resp.put("status", e.getStatus().value());
		resp.put("error", e.getStatus());
		resp.put("message", e.getReason());

		try {
			Object developMessage = e.getClass().getMethod(
				"getDevelopMessage"
			).invoke(e);

			if (developMessage != null) {
				resp.put("developMessage", developMessage);
			}
		} catch (Exception ex) {
			logger.info("No develop message send");
		}

		logger.error(e.getMessage());
		return new ResponseEntity${(}>(
			resp,
			e.getStatus()
		);
	}

}
  </layout>

  <layout extension=".java" dir="/exception/ForbiddenException">${package}

import org.springframework.http.HttpStatus;
import org.springframework.web.server.ResponseStatusException;

public class ForbiddenException extends ResponseStatusException {

	private String developMessage;

	public ForbiddenException(String reason) {
		super(HttpStatus.FORBIDDEN, reason);
	}

	public ForbiddenException(String reason, String developMessage) {
		super(HttpStatus.FORBIDDEN, reason);
		this.developMessage = developMessage;
	}

	public String getDevelopMessage() {
		return developMessage;
	}

}
  </layout>

  <layout extension=".java" dir="/exception/BadRequestException">${package}

import org.springframework.http.HttpStatus;
import org.springframework.web.server.ResponseStatusException;

public class BadRequestException extends ResponseStatusException {

	private String developMessage;

	public BadRequestException(String reason) {
		super(HttpStatus.BAD_REQUEST, reason);
	}

	public BadRequestException(String reason, String developMessage) {
		super(HttpStatus.BAD_REQUEST, reason);
		this.developMessage = developMessage;
	}

	public String getDevelopMessage() {
		return developMessage;
	}

}
  </layout>
  <!--=================================================-->

  <!--entity-->
  <layout extension=".java" dir="/entity/User">${package}

import java.io.Serializable;
import java.util.List;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;

import ${intoSrc}.util.Text;

@Entity
@Table(name = "users")
public class User implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	private String name;
	private String lastName;
	private String phoneNumber;
	private String imageUrl;
	private String userName;
	private String email;
	private String password;
	private String recoverCode;

	@Column(columnDefinition = "boolean default true")
	private boolean firstSession;

	@Column(columnDefinition = "boolean default false")
	private boolean blocked;

	@Column(columnDefinition = "boolean default false")
	private boolean delete;

	@ManyToMany(fetch=FetchType.LAZY, cascade=CascadeType.ALL)
	@JoinTable(
		name = "user_role", joinColumns = @JoinColumn(name = "user_id"),
		inverseJoinColumns = @JoinColumn(name="role_id"),
		uniqueConstraints = { @UniqueConstraint(columnNames = {"user_id", "role_id"}) }
	)
	private List${(}Role> roles;


	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public List${(}Role> getRoles() {
		return roles;
	}

	public void setRoles(List${(}Role> roles) {
		this.roles = roles;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public String getPhoneNumber() {
		return phoneNumber;
	}

	public void setPhoneNumber(String phoneNumber) {
		this.phoneNumber = phoneNumber;
	}

	public String getImageUrl() {
		return imageUrl;
	}

	public void setImageUrl(String imageUrl) {
		this.imageUrl = imageUrl;
	}

	public boolean isFirstSession() {
		return firstSession;
	}

	public void setFirstSession(boolean firstSession) {
		this.firstSession = firstSession;
	}

	public boolean isBlocked() {
		return blocked;
	}

	public void setBlocked(boolean blocked) {
		this.blocked = blocked;
	}

	public boolean isDelete() {
		return delete;
	}

	public void setDelete(boolean delete) {
		this.delete = delete;
	}

	public String getRecoverCode() {
		return recoverCode;
	}

	public void setRecoverCode(String recoverCode) {
		this.recoverCode = recoverCode;
	}

	@Override
	public String toString() {
		return Text.toJSONString(this);
	}

}
  </layout>

  <layout extension=".java" dir="/entity/Role">${package}

import java.io.Serializable;
import java.util.List;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToMany;
import javax.persistence.Table;

import ${intoSrc}.util.Text;

@Entity
@Table(name = "role")
public class Role implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue( strategy = GenerationType.IDENTITY )
	private Long id;

	private String name;

	@ManyToMany(mappedBy = "roles")
	private List${(}User> users;

	public List${(}User> getUsers() {
				return users;
		}

	public void setUsers(List${(}User> users) {
			this.users = users;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return Text.toJSONString(this);
	}

}
  </layout>
  <!--=================================================-->

  <!--dao-->
  <layout extension=".java" dir="/dao/IRoleDAO">${package}

import java.util.Optional;

import ${intoSrc}.entity.Role;

import org.springframework.data.jpa.repository.JpaRepository;

public interface IRoleDAO extends JpaRepository${(}Role, Long> {
	Optional${(}Role> findByName(String name);
	Optional${(}Role> findById(Long id);
}
  </layout>

  <layout extension=".java" dir="/dao/IUserDAO">${package}

import java.util.Optional;

import ${intoSrc}.entity.User;

import org.springframework.data.jpa.repository.JpaRepository;

public interface IUserDAO extends JpaRepository${(}User, Long> {
	Optional${(}User> findByUserName(String userName);
	Optional${(}User> findByEmail(String userName);
	Optional${(}User> findByPhoneNumber(String phoneNumber);
	Optional${(}User> findByRecoverCode(String recoverCode);
}
  </layout>
  <!--=================================================-->

  <!--controller-->
  <layout extension=".java" dir="/controller/AuthController">${package}

import java.util.Map;

import org.neurobrain.tlozbotw.exception.HttpExceptionResponse;
import org.neurobrain.tlozbotw.service.interfaces.IAuthService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;


@CrossOrigin(origins = "*")
@RestController
@RequestMapping("/auth")
public class AuthController {

	@Autowired
	private IAuthService authService;

	@Autowired
	private HttpExceptionResponse httpExceptionResponse;

	/**
	 	@apiGroup Auth
		@apiVersion 0.0.1
		@apiDescription Servicio para registrar un nuevo usuario
		@api {post} auth/signup/ signup
		@apiPermission none

		@apiParamExample {json} Request-Body:
			{
				"name": "your user name",
				"lastName": "your last name",
				"phoneNumber": "your phone number",
				"imageUrl": "your account photo",
				"userName": "your user name",
				"email": "your email"
			}

		@apiSuccessExample {json} HTTP/1.1 200 OK
			{
				"timestamp": "2020-01-03T04:05:37.126+0000",
				"status": 200,
				"message": "your success message"
			}

		@apiErrorExample {json} HTTP/1.1 400 Bad Request
			{
				"timestamp": "2020-01-03T16:42:13.727+0000",
				"status": 400,
				"error": "BAD_REQUEST",
				"message": "your problem message"
			}

		@apiErrorExample {json} HTTP/1.1 500 Internal Server Error
			{
				"timestamp": "2020-01-03T17:37:02.348+0000",
				"status": 500,
				"error": "Internal Server Error",
				"message": "your error message"
			}
	*/
	@PostMapping("/signup")
	public ResponseEntity${(}Object> signup(
		@RequestBody Map${(}String, Object> req
	) {
		try {
			return authService.signup(req);
		} catch (ResponseStatusException e) {
			return httpExceptionResponse.error(e);
		}
	}

	/**
	 	@apiGroup Auth
		@apiVersion 0.0.1
		@apiDescription Servicio para iniciar sesi√≥n
		@api {post} auth/signin signin
		@apiPermission none

		@apiParamExample {json} Request-Body:
			{
				"userName": "email | user name | phone number",
				"password": "your password"
			}

		@apiSuccessExample {json} HTTP/1.1 200 OK
			{
				"timestamp": "2020-01-03T20:21:07.712+0000",
				"status": 200,
				"data": {
					"id": identify id,
					"type": "Bearer",
					"token": "your token",
					"name": "your name",
					"lastName": "your last name",
					"phoneNumber": "your phone number",
					"imageUrl": "your account photo",
					"userName": "your user name",
					"email": "your email",
					"firstSession": true | false,
					"roles": [
						"your roles"
					]
				}
			}

		@apiErrorExample {json} HTTP/1.1 400 Bad Request
			{
				"timestamp": "2020-01-03T16:42:13.727+0000",
				"status": 400,
				"error": "BAD_REQUEST",
				"message": "your problem message"
			}

		@apiErrorExample {json} HTTP/1.1 500 Internal Server Error
			{
				"timestamp": "2020-01-03T17:37:02.348+0000",
				"status": 500,
				"error": "Internal Server Error",
				"message": "your error message"
			}
	*/
	@PostMapping("/signin")
	public ResponseEntity${(}Object> signin(
		@RequestBody Map${(}String, Object> req
	) {
		try {
			return authService.signin(req);
		} catch (ResponseStatusException e) {
			return httpExceptionResponse.error(e);
		}
	}

	/**
	 	@apiGroup Auth
		@apiVersion 0.0.1
		@apiDescription Servicio para recuperar contrase√±a del usuario
		@api {post} auth/recoverPassword recoverPassword
		@apiPermission none

		@apiParamExample {json} Request-Body:
			{
				"email": "your email"
			}

		@apiSuccessExample {json} HTTP/1.1 200 OK
			{
				"timestamp": "2020-01-03T21:44:34.107+0000",
				"status": 200,
				"message": "your success message"
			}

		@apiErrorExample {json} HTTP/1.1 400 Bad Request
			{
				"timestamp": "2020-01-03T16:42:13.727+0000",
				"status": 400,
				"error": "BAD_REQUEST",
				"message": "your problem message"
			}

		@apiErrorExample {json} HTTP/1.1 500 Internal Server Error
			{
				"timestamp": "2020-01-03T17:37:02.348+0000",
				"status": 500,
				"error": "Internal Server Error",
				"message": "your error message"
			}
	*/
	@PostMapping("/recoverPassword")
	public ResponseEntity${(}Object> recoverPassword(
		@RequestBody Map${(}String, Object> req
	) {
		try {
			return authService.recoverPassword(req);
		} catch (ResponseStatusException e) {
			return httpExceptionResponse.error(e);
		}
	}

	/**
	 	@apiGroup Auth
		@apiVersion 0.0.1
		@apiDescription Servicio para cambiar la contrase√±a recuperada
		@api {post} auth/changePassword changePassword
		@apiPermission none

		@apiParamExample {json} Request-Body:
			{
				"code": "your code",
				"password": "your new password"
			}

		@apiSuccessExample {json} HTTP/1.1 200 OK
			{
				"timestamp": "2020-01-03T21:45:16.951+0000",
				"status": 200,
				"message": "your success message"
			}

		@apiErrorExample {json} HTTP/1.1 400 Bad Request
			{
				"timestamp": "2020-01-03T16:42:13.727+0000",
				"status": 400,
				"error": "BAD_REQUEST",
				"message": "your problem message"
			}

		@apiErrorExample {json} HTTP/1.1 500 Internal Server Error
			{
				"timestamp": "2020-01-03T17:37:02.348+0000",
				"status": 500,
				"error": "Internal Server Error",
				"message": "your error message"
			}
	*/
	@PostMapping("/changePassword")
	public ResponseEntity${(}Object> changePassword(
		@RequestBody Map${(}String, Object> req
	)	{
		try {
			return authService.changePassword(req);
		} catch (ResponseStatusException e) {
			return httpExceptionResponse.error(e);
		}
	}

}
  </layout>

  <layout extension=".java" dir="/controller/UserController">${package}

import java.util.Map;

import ${intoSrc}.exception.HttpExceptionResponse;
import ${intoSrc}.service.interfaces.IUserService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

@CrossOrigin(origins = "*")
@RestController
@RequestMapping("/user")
public class UserController {

	@Autowired
	private IUserService userService;

	@Autowired
	private HttpExceptionResponse httpExceptionResponse;

	/**
	 	@apiGroup User
		@apiVersion 0.0.1
		@apiDescription Servicio para iniciar sesi√≥n por primera vez
		@api {post} user/firstSignin/:id firstSignin
		@apiPermission {user} {admin}

		@apiParam {number} Id Identificador √∫nico

		@apiParamExample {json} Request-Body:
			{
	 			"password": "your password"
			}

		@apiSuccessExample {json} HTTP/1.1 200 OK
			{
				"timestamp": "2020-01-03T04:05:37.126+0000",
				"status": 200,
				"message": "your success message"
			}

		@apiErrorExample {json} HTTP/1.1 400 Bad Request
			{
				"timestamp": "2020-01-04T21:55:33.365+0000",
				"status": 400,
				"error": "BAD_REQUEST",
				"message": "User already had his first login"
			}

		@apiErrorExample {json} HTTP/1.1 401 Unauthorized
			{
				"timestamp": "2020-01-03T04:17:06.006+0000",
				"status": 401,
				"error": "Unauthorized",
				"message": "Full authentication is required to access this resource"
			}

		@apiErrorExample {json} HTTP/1.1 500 Internal Server Error
			{
				"timestamp": "2020-01-03T17:37:02.348+0000",
				"status": 500,
				"error": "Internal Server Error",
				"message": "your error message"
			}
	*/
	@PostMapping("/firstSignin/{id}")
	@PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
	public ResponseEntity${(}Object> firstSignin(
		@PathVariable("id") Long id,
		@RequestBody Map${(}String, Object> req
	) {
		try {
			return userService.firstSignin(id, req);
		} catch (ResponseStatusException e) {
			return httpExceptionResponse.error(e);
		}
	}

	/**
		@apiGroup User
		@apiVersion 0.0.1
		@apiDescription Servicio para actualizar un usuario
		@api {put} user/update/:id update
		@apiPermission {user} {admin}

		@apiParam {number} Id Identificador √∫nico

		@apiParamExample {json} Request-Body:
			{
				"name": "your name",
				"lastName": "your last name",
				"phoneNumber": "your phone number",
				"imageUrl": "your account photo",
				"userName": "your user name"
			}

		@apiSuccessExample {json} HTTP/1.1 200 OK
			{
				"timestamp": "2020-01-03T18:03:54.033+0000",
				"status": 200,
				"message": "your success message",
				"data": {
					"id": identify id,
					"name": "your name",
					"lastName": "your last name",
					"phoneNumber": "your phone number",
					"imageUrl": "your account photo",
					"userName": "your user name",
					"email": "your email",
					"roles": [
						"your roles"
					]
				}
			}

		@apiErrorExample {json} HTTP/1.1 400 Bad Request
			{
				"timestamp": "2020-01-03T18:13:58.035+0000",
				"status": 400,
				"error": "BAD_REQUEST",
				"message": "your problem message"
			}

		@apiErrorExample {json} HTTP/1.1 401 Unauthorized
			{
				"timestamp": "2020-01-03T04:17:06.006+0000",
				"status": 401,
				"error": "Unauthorized",
				"message": "Full authentication is required to access this resource"
			}

		@apiErrorExample {json} HTTP/1.1 500 Internal Server Error
			{
				"timestamp": "2020-01-03T17:37:02.348+0000",
				"status": 500,
				"error": "Internal Server Error",
				"message": "your error message"
			}
	*/
	@PutMapping("/update/{id}")
	@PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
	public ResponseEntity${(}Object> update(
		@PathVariable("id") Long id,
		@RequestBody Map${(}String, Object> req
	) {
		try {
			return userService.update(id, req);
		} catch (ResponseStatusException e) {
			return httpExceptionResponse.error(e);
		}
	}

	/**
		@apiGroup User
		@apiVersion 0.0.1
		@apiDescription Servicio para bloquear y desbloquear un usuario
		@api {put} user/blocked/:id blocked
		@apiPermission {admin}

		@apiParam {number} Id Identificador √∫nico

		@apiParamExample {json} Request-Body:
			{
				"blocked": true | false
			}

		@apiSuccessExample {json} HTTP/1.1 200 OK
			{
				"timestamp": "2020-01-03T18:35:29.813+0000",
				"status": 200,
				"message": "your success message"
			}

		@apiErrorExample {json} HTTP/1.1 400 Bad Request
			{
				"timestamp": "2020-01-03T18:13:58.035+0000",
				"status": 400,
				"error": "BAD_REQUEST",
				"message": "your problem message",
				"trace": "your trace catch",
				"path": "/user/blocked/:id"
			}

		@apiErrorExample {json} HTTP/1.1 401 Unauthorized
			{
				"timestamp": "2020-01-03T04:17:06.006+0000",
				"status": 401,
				"error": "Unauthorized",
				"message": "Full authentication is required to access this resource"
			}

		@apiErrorExample {json} HTTP/1.1 500 Internal Server Error
			{
				"timestamp": "2020-01-03T17:37:02.348+0000",
				"status": 500,
				"error": "Internal Server Error",
				"message": "your error message"
			}
	*/
	@PutMapping("/blocked/{id}")
	@PreAuthorize("hasRole('ADMIN')")
	public ResponseEntity${(}Object> blocked(
		@PathVariable("id") Long id,
		@RequestBody Map${(}String, Object> req
	) {
		try {
			return userService.blocked(id, req);
		} catch (ResponseStatusException e) {
			return httpExceptionResponse.error(e);
		}
	}

	/**
		@apiGroup User
		@apiVersion 0.0.1
		@apiDescription Servicio para eliminar un usuario (eliminaci√≥n l√≥gica)
		@api {delete} user/delete/:id delete
		@apiPermission {admin}

		@apiParam {number} Id Identificador √∫nico

		@apiSuccessExample {json} HTTP/1.1 200 OK
			{
				"timestamp": "2020-01-03T18:41:46.305+0000",
				"status": 200,
				"message": "your success message"
			}

		@apiErrorExample {json} HTTP/1.1 400 Bad Request
			{
				"timestamp": "2020-01-03T18:13:58.035+0000",
				"status": 400,
				"error": "BAD_REQUEST",
				"message": "your problem message",
				"trace": "your trace catch"
			}

		@apiErrorExample {json} HTTP/1.1 401 Unauthorized
			{
				"timestamp": "2020-01-03T04:17:06.006+0000",
				"status": 401,
				"error": "Unauthorized",
				"message": "Full authentication is required to access this resource"
			}

		@apiErrorExample {json} HTTP/1.1 500 Internal Server Error
			{
				"timestamp": "2020-01-03T17:37:02.348+0000",
				"status": 500,
				"error": "Internal Server Error",
				"message": "your error message"
			}
	*/
	@DeleteMapping("/delete/{id}")
	@PreAuthorize("hasRole('ADMIN')")
	public ResponseEntity${(}Object> delete(
		@PathVariable("id") Long id
	) {
		try {
			return userService.delete(id);
		} catch (ResponseStatusException e) {
			return httpExceptionResponse.error(e);
		}
	}

}
  </layout>
  <!--=================================================-->
</root>
